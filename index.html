<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Voice Obstacle Game</title>
<style>
body { margin: 0; background: #111; color: #fff; font-family: sans-serif; overflow: hidden; }
#menu { position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; flex-direction: column; }
.song-button { padding: 10px 20px; margin: 10px; cursor: pointer; background: #222; color: #fff; border: 1px solid #555; border-radius: 5px; }
#gameCanvas { display: block; margin: auto; background: #000; }
#hud { position: absolute; top: 10px; left: 10px; font-size: 18px; z-index: 10; }
</style>
</head>
<body>

<div id="menu">
    <h1>Выберите песню</h1>
    <div id="songButtons"></div>
</div>

<canvas id="gameCanvas"></canvas>
<div id="hud">
    <div>Очки: <span id="score">0</span></div>
    <div>Комбо: <span id="combo">0</span></div>
    <div>Точность: <span id="accuracy">0%</span></div>
</div>

<audio id="audio"></audio>

<script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.27/build/Midi.js"></script>

<script>
// ----------------- Константы -----------------
const CANVAS_WIDTH = 1600;
const CANVAS_HEIGHT = 900;

let audioContext, analyser, micStream, dataArray, currentPitch = null;
let audio = document.getElementById("audio");
let canvas = document.getElementById("gameCanvas");
let ctx = canvas.getContext("2d");

// Настройка canvas
canvas.width = CANVAS_WIDTH;
canvas.height = CANVAS_HEIGHT;

// ----------------- Игровые объекты -----------------
let ball = { x: 250, y: CANVAS_HEIGHT/2, radius: 30 };
let obstacles = [];
let subtitles = [];
let currentSubtitle = "";
let score = 0, combo = 0, accuracy = 0;

// ----------------- Голосовое управление -----------------
function autoCorrelate(buffer, sampleRate){
    let SIZE = buffer.length;
    let rms=0;
    for(let i=0;i<SIZE;i++) rms+=buffer[i]*buffer[i];
    rms=Math.sqrt(rms/SIZE);
    if(rms<0.01) return null;

    let r=new Array(SIZE).fill(0);
    for(let lag=0;lag<SIZE;lag++)
        for(let i=0;i<SIZE-lag;i++)
            r[lag]+=buffer[i]*buffer[i+lag];

    let d=0; while(r[d]>r[d+1]) d++;
    let maxval=-1,maxpos=-1;
    for(let i=d;i<SIZE;i++){ if(r[i]>maxval){ maxval=r[i]; maxpos=i; } }
    let T0=maxpos;
    if(T0===0) return null;
    return sampleRate/T0;
}

function updatePitch(){
    if(!analyser) return null;
    analyser.getFloatTimeDomainData(dataArray);
    let freq = autoCorrelate(dataArray, audioContext.sampleRate);
    currentPitch = freq;
    return freq;
}

async function initMic(){
    if(!audioContext) audioContext = new (window.AudioContext||window.webkitAudioContext)();
    if(audioContext.state==="suspended") await audioContext.resume();

    try{
        micStream = await navigator.mediaDevices.getUserMedia({audio:true});
        const micSource = audioContext.createMediaStreamSource(micStream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        micSource.connect(analyser);
        dataArray = new Float32Array(analyser.fftSize);
    }catch(err){
        alert("Ошибка микрофона: "+err);
        throw err;
    }
}

// ----------------- Субтитры -----------------
async function loadSRT(url){
    const res=await fetch(url);
    const text=await res.text();
    parseSRT(text);
}

function parseSRT(text){
    subtitles=[];
    text=text.replace(/\r\n/g,'\n').replace(/\r/g,'\n');
    const blocks=text.split(/\n{2,}/);
    blocks.forEach(block=>{
        const lines=block.trim().split('\n');
        if(lines.length>=2){
            let timeLine=lines[0].includes('-->') ? lines[0] : lines[1];
            const times=timeLine.split(' --> ');
            const start=parseTime(times[0]);
            const end=parseTime(times[1]);
            const textLines=lines.slice(timeLine===lines[0]?1:2);
            subtitles.push({start,end,text:textLines.join(' ')});
        }
    });
}

function parseTime(timeStr){
    const parts=timeStr.split(/[:,]/);
    return parseInt(parts[0])*3600+parseInt(parts[1])*60+parseInt(parts[2])+parseInt(parts[3])/1000;
}

function updateSubtitles(){
    const t = audio.currentTime;
    currentSubtitle="";
    for(let i=0;i<subtitles.length;i++){
        if(t>=subtitles[i].start && t<=subtitles[i].end){
            currentSubtitle=subtitles[i].text;
            break;
        }
    }
}

// ----------------- Голос → Y -----------------
function mapFreqToY(freq){
    if(!freq) return ball.y;
    const minFreq=100, maxFreq=1000;
    const minY=50, maxY=CANVAS_HEIGHT-50;
    freq=Math.max(minFreq,Math.min(maxFreq,freq));
    return maxY-(freq-minFreq)/(maxFreq-minFreq)*(maxY-minY);
}

// ----------------- Генерация препятствий -----------------
let lastObstacleTime = 0;
function spawnObstacle(deltaTime){
    lastObstacleTime += deltaTime;
    if(lastObstacleTime>1){ // новое препятствие каждые ~1 сек
        lastObstacleTime=0;
        const width = 50 + Math.random()*100;
        const height = 50 + Math.random()*300;
        const y = Math.random()*(CANVAS_HEIGHT-height-50)+25;
        obstacles.push({x:CANVAS_WIDTH, y:y, w:width, h:height, passed:false});
    }
}

// ----------------- GameLoop -----------------
function gameLoop(time){
    ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);
    updatePitch();
    ball.y = mapFreqToY(currentPitch);

    const deltaTime = 1/60;
    spawnObstacle(deltaTime);

    // обновление препятствий
    for(let i=0;i<obstacles.length;i++){
        let obs = obstacles[i];
        obs.x -= 5;
        ctx.fillStyle="#f00";
        ctx.fillRect(obs.x, obs.y, obs.w, obs.h);

        if(!obs.passed && ball.x+ball.radius>obs.x && ball.x-ball.radius<obs.x+obs.w &&
           ball.y+ball.radius>obs.y && ball.y-ball.radius<obs.y+obs.h){
            combo = 0; // столкновение сбрасывает комбо
            obs.passed = true;
        } else if(!obs.passed && obs.x+obs.w<ball.x-ball.radius){
            score += 10;
            combo++;
            if(combo%5===0) score += 50;
            obs.passed=true;
        }
    }

    // шарик
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius,0,2*Math.PI);
    ctx.fillStyle="#0f0";
    ctx.fill();

    // субтитры
    updateSubtitles();
    ctx.fillStyle="#fff";
    ctx.font="24px sans-serif";
    ctx.textAlign="center";
    ctx.fillText(currentSubtitle, CANVAS_WIDTH/2, CANVAS_HEIGHT-50);

    // обновление HUD
    document.getElementById("score").textContent=score;
    document.getElementById("combo").textContent=combo;
    document.getElementById("accuracy").textContent=accuracy+"%";

    requestAnimationFrame(gameLoop);
}

// ----------------- Масштабирование canvas -----------------
function resizeCanvas(){
    const windowRatio = window.innerWidth / window.innerHeight;
    const gameRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
    let width, height;
    if(windowRatio > gameRatio){
        height = window.innerHeight;
        width = height * gameRatio;
    } else {
        width = window.innerWidth;
        height = width / gameRatio;
    }
    canvas.style.width = width + "px";
    canvas.style.height = height + "px";
}

window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// ----------------- Старт игры -----------------
async function startGame(song){
    document.getElementById("menu").style.display="none";
    await initMic();
    audio.src = song.audio;
    await loadSRT(song.lyrics);
    audio.play();
    requestAnimationFrame(gameLoop);
}

// ----------------- Меню -----------------
const songs=[{title:"Song 1", audio:"songs/song1.mp3", lyrics:"songs/song1.srt"}];
const songButtonsDiv=document.getElementById("songButtons");
songs.forEach(song=>{
    let btn=document.createElement("div");
    btn.className="song-button";
    btn.textContent=song.title;
    btn.onclick=()=>startGame(song);
    songButtonsDiv.appendChild(btn);
});
</script>

</body>
</html>
