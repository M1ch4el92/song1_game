<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Voice Rhythm Game PRO</title>

<style>
body { margin:0; background:black; color:white; font-family:sans-serif; overflow:hidden;}
#menu { position:absolute; width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; background:black; }
button { padding:12px 24px; margin:10px; font-size:18px; cursor:pointer; }

#ui { position:absolute; top:10px; left:10px; }
#subtitle { position:absolute; bottom:40px; width:100%; text-align:center; font-size:26px; }
#judgement { position:absolute; top:110px; left:10px; font-size:22px; }

canvas { display:block; }
</style>
</head>
<body>

<div id="menu"></div>

<div id="ui">
<div id="score">Score: 0</div>
<div id="accuracy">Accuracy: 0%</div>
<div id="combo">Combo: 0</div>
<div id="judgement"></div>
</div>

<div id="subtitle"></div>
<canvas id="game"></canvas>

<script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.27/build/Midi.js"></script>
<script>

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let audio = new Audio();
let audioContext, analyser, dataArray;

let score = 0;
let combo = 0;
let hits = 0;
let total = 0;

let ball = { x:150, y:canvas.height/2, r:15 };
let notes = [];
let obstacles = [];
let subtitles = [];


// ================= MENU =================

async function loadMenu(){
    const res = await fetch("songs.json");
    const songs = await res.json();
    const menu = document.getElementById("menu");

    songs.forEach(song=>{
        const btn = document.createElement("button");
        btn.innerText = song.title;
        btn.onclick = () => startGame(song);
        menu.appendChild(btn);
    });
}

async function startGame(song){
    document.getElementById("menu").style.display="none";
    await initMic();

    audio.src = song.audio;
    await loadMidi(song.midi);
    await loadSRT(song.lyrics);

    audio.play();
    gameLoop();
}


// ================= MIDI =================

async function loadMidi(path){
    const res = await fetch(path);
    const arrayBuffer = await res.arrayBuffer();
    const midi = new Midi(arrayBuffer);

    notes = [];

    midi.tracks.forEach(track=>{
        track.notes.forEach(n=>{
            notes.push({
                time: n.time,
                freq: 440 * Math.pow(2,(n.midi-69)/12),
                spawned:false
            });
        });
    });
}


// ================= SRT =================

async function loadSRT(path){
    const res = await fetch(path);
    const text = await res.text();
    subtitles = [];

    const blocks = text.split(/\n\s*\n/);

    blocks.forEach(block=>{
        const lines = block.split("\n");
        if(lines.length >= 3){
            const times = lines[1].split(" --> ");
            const start = parseSRTTime(times[0]);
            const end = parseSRTTime(times[1]);
            const content = lines.slice(2).join(" ");

            subtitles.push({ start, end, text: content });
        }
    });
}

function parseSRTTime(timeStr){
    const parts = timeStr.split(":");
    const secParts = parts[2].split(",");
    return (
        parseInt(parts[0])*3600 +
        parseInt(parts[1])*60 +
        parseInt(secParts[0]) +
        parseInt(secParts[1])/1000
    );
}


// ================= MIC =================

async function initMic(){
    audioContext = new AudioContext();
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    const mic = audioContext.createMediaStreamSource(stream);

    analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;

    mic.connect(analyser);
    dataArray = new Float32Array(analyser.fftSize);
}


// ================= PITCH =================

function autoCorrelate(buffer, sampleRate){
    let SIZE = buffer.length;
    let rms=0;
    for(let i=0;i<SIZE;i++) rms+=buffer[i]*buffer[i];
    rms=Math.sqrt(rms/SIZE);
    if(rms<0.01) return -1;

    let c=new Array(SIZE).fill(0);
    for(let i=0;i<SIZE;i++)
        for(let j=0;j<SIZE-i;j++)
            c[i]+=buffer[j]*buffer[j+i];

    let maxpos=0,maxval=0;
    for(let i=1;i<SIZE;i++)
        if(c[i]>maxval){maxval=c[i];maxpos=i;}

    return sampleRate/maxpos;
}

function updatePitch(){
    analyser.getFloatTimeDomainData(dataArray);
    const freq = autoCorrelate(dataArray,audioContext.sampleRate);

    if(freq>0){
        let norm = (freq-100)/900;
        norm = Math.max(0,Math.min(1,norm));
        ball.y = canvas.height - norm*canvas.height;
        return freq;
    }
    return null;
}


// ================= GAME =================

function spawnNotes(){
    const time = audio.currentTime;

    notes.forEach(n=>{
        if(!n.spawned && time >= n.time - 1){
            obstacles.push({
                x:canvas.width,
                y:canvas.height - ((n.freq-100)/900)*canvas.height,
                target:n.freq,
                hit:false
            });
            n.spawned = true;
            total++;
        }
    });
}

function updateObstacles(freq){
    obstacles.forEach(o=>{
        o.x -= 6;

        if(Math.abs(o.x-ball.x)<20 && !o.hit){
            if(freq){
                const diff = Math.abs(freq-o.target);
                const percent = Math.max(0,100 - diff/4);

                document.getElementById("accuracy").innerText =
                    "Accuracy: " + percent.toFixed(0) + "%";

                let judgement = "";

                if(diff < 10){
                    judgement = "Perfect!";
                    score += 20 + combo*3;
                    combo++;
                    hits++;
                    o.hit=true;
                }
                else if(diff < 25){
                    judgement = "Good";
                    score += 10 + combo*2;
                    combo++;
                    hits++;
                    o.hit=true;
                }
                else{
                    judgement = "Miss";
                    combo=0;
                }

                document.getElementById("judgement").innerText = judgement;
                document.getElementById("score").innerText = "Score: "+score;
                document.getElementById("combo").innerText = "Combo: "+combo;
            }
        }
    });

    obstacles = obstacles.filter(o=>o.x>-50);
}

function updateSubtitles(){
    const time = audio.currentTime;
    let current="";
    subtitles.forEach(s=>{
        if(time>=s.start && time<=s.end){
            current=s.text;
        }
    });
    document.getElementById("subtitle").innerText=current;
}

function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle="white";
    ctx.beginPath();
    ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2);
    ctx.fill();

    obstacles.forEach(o=>{
        ctx.fillStyle=o.hit?"green":"red";
        ctx.fillRect(o.x,o.y-40,20,80);
    });
}

function gameLoop(){
    const freq = updatePitch();
    spawnNotes();
    updateObstacles(freq);
    updateSubtitles();
    draw();
    requestAnimationFrame(gameLoop);
}

loadMenu();

</script>
</body>
</html>
