<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Voice Rhythm Game</title>
<style>
    body { margin: 0; background: #111; color: #fff; font-family: sans-serif; overflow: hidden; }
    #menu { position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; flex-direction: column; }
    .song-button { padding: 10px 20px; margin: 10px; cursor: pointer; background: #222; color: #fff; border: 1px solid #555; border-radius: 5px; }
    #gameCanvas { display: block; margin: auto; background: #000; }
    #hud { position: absolute; top: 10px; left: 10px; font-size: 18px; z-index: 10; }
</style>
</head>
<body>

<div id="menu">
    <h1>Выберите песню</h1>
    <div id="songButtons"></div>
</div>

<canvas id="gameCanvas"></canvas>
<div id="hud">
    <div>Очки: <span id="score">0</span></div>
    <div>Комбо: <span id="combo">0</span></div>
    <div>Точность: <span id="accuracy">0%</span></div>
</div>

<audio id="audio"></audio>

<script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.27/build/Midi.js"></script>

<script>
// ------------------ Константы ------------------
const CANVAS_WIDTH = 1600;
const CANVAS_HEIGHT = 900;

let audioContext, analyser, micStream, dataArray, currentPitch = null;
let audio = document.getElementById("audio");
let canvas = document.getElementById("gameCanvas");
let ctx = canvas.getContext("2d");

// Canvas размер
canvas.width = CANVAS_WIDTH;
canvas.height = CANVAS_HEIGHT;

// ------------------ Игровые объекты ------------------
let ball = { x: 250, y: CANVAS_HEIGHT/2, radius: 30 };
let obstacles = [];
let subtitles = [];
let currentSubtitle = "";
let score = 0, combo = 0, accuracy = 0;

// ------------------ Голосовой анализ ------------------
function autoCorrelate(buffer, sampleRate){
    let SIZE = buffer.length;
    let rms = 0;
    for (let i=0;i<SIZE;i++) rms += buffer[i]*buffer[i];
    rms = Math.sqrt(rms/SIZE);
    if(rms<0.01) return null;

    let r = new Array(SIZE).fill(0);
    for(let lag=0;lag<SIZE;lag++)
        for(let i=0;i<SIZE-lag;i++)
            r[lag]+=buffer[i]*buffer[i+lag];

    let d=0; while(r[d]>r[d+1]) d++;
    let maxval=-1,maxpos=-1;
    for(let i=d;i<SIZE;i++){ if(r[i]>maxval){ maxval=r[i]; maxpos=i; } }
    let T0=maxpos;
    if(T0===0) return null;
    return sampleRate/T0;
}

function updatePitch(){
    if(!analyser) return null;
    analyser.getFloatTimeDomainData(dataArray);
    let freq = autoCorrelate(dataArray, audioContext.sampleRate);
    currentPitch = freq;
    return freq;
}

async function initMic(){
    if(!audioContext) audioContext = new (window.AudioContext||window.webkitAudioContext)();
    if(audioContext.state==="suspended") await audioContext.resume();

    try{
        micStream = await navigator.mediaDevices.getUserMedia({audio:true});
        const micSource = audioContext.createMediaStreamSource(micStream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        micSource.connect(analyser);
        dataArray = new Float32Array(analyser.fftSize);
        console.log("Микрофон подключён");
    }catch(err){
        alert("Ошибка микрофона: "+err);
        throw err;
    }
}

// ------------------ MIDI и препятствия ------------------
async function loadMidi(url){
    const response = await fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    const midi = new Midi(arrayBuffer);
    createObstaclesFromMidi(midi);
}

function createObstaclesFromMidi(midi){
    obstacles = [];
    midi.tracks.forEach(track=>{
        track.notes.forEach(note=>{
            obstacles.push({
                time: note.time,
                note: note.midi,
                y: mapMidiToY(note.midi),
                hit: false
            });
        });
    });
}

function mapMidiToY(midiNote){
    const minY = 50, maxY = CANVAS_HEIGHT-50;
    const minNote = 40, maxNote = 80;
    midiNote = Math.max(minNote, Math.min(maxNote, midiNote));
    return maxY - (midiNote-minNote)/(maxNote-minNote)*(maxY-minY);
}

// ------------------ SRT субтитры ------------------
async function loadSRT(url){
    const res = await fetch(url);
    const text = await res.text();
    parseSRT(text);
}

function parseSRT(text){
    subtitles = [];
    text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    const blocks = text.split(/\n{2,}/);
    blocks.forEach(block=>{
        const lines = block.trim().split("\n");
        if(lines.length >= 2){
            let timeLine = lines[0].includes('-->') ? lines[0] : lines[1];
            const times = timeLine.split(' --> ');
            const start = parseTime(times[0]);
            const end = parseTime(times[1]);
            const textLines = lines.slice(timeLine === lines[0] ? 1 : 2);
            subtitles.push({
                start: start,
                end: end,
                text: textLines.join(' ')
            });
        }
    });
}

function parseTime(timeStr){
    const parts = timeStr.split(/[:,]/);
    return parseInt(parts[0])*3600 + parseInt(parts[1])*60 + parseInt(parts[2]) + parseInt(parts[3])/1000;
}

function updateSubtitles(){
    const t = audio.currentTime;
    currentSubtitle = "";
    for(let i=0;i<subtitles.length;i++){
        if(t >= subtitles[i].start && t <= subtitles[i].end){
            currentSubtitle = subtitles[i].text;
            break;
        }
    }
}

// ------------------ Голосовое движение ------------------
function mapFreqToY(freq){
    if(!freq) return ball.y;
    let minFreq=100, maxFreq=1000;
    let minY=50, maxY=CANVAS_HEIGHT-50;
    freq = Math.max(minFreq, Math.min(maxFreq, freq));
    return maxY - (freq-minFreq)/(maxFreq-minFreq)*(maxY-minY);
}

// ------------------ GameLoop ------------------
function gameLoop(){
    ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);

    updatePitch();
    ball.y = mapFreqToY(currentPitch);

    let currentTime = audio.currentTime;

    // препятствия
    obstacles.forEach(obs=>{
        let x = CANVAS_WIDTH - (currentTime-obs.time)*300;
        if(x>-20){
            ctx.fillStyle = obs.hit?"#00f":"#f00";
            ctx.fillRect(x, obs.y-10, 20, 20);

            if(!obs.hit && Math.abs(ball.y-obs.y)<40 && Math.abs(x-ball.x)<25){
                obs.hit = true;
                score+=10;
                combo+=1;
                accuracy=Math.min(100,accuracy+5);
                document.getElementById("score").textContent = score;
                document.getElementById("combo").textContent = combo;
                document.getElementById("accuracy").textContent = accuracy + "%";
            }
        }
    });

    // шарик
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius,0,2*Math.PI);
    ctx.fillStyle="#0f0";
    ctx.fill();

    // субтитры
    updateSubtitles();
    ctx.fillStyle="#fff";
    ctx.font="24px sans-serif";
    ctx.textAlign="center";
    ctx.fillText(currentSubtitle, CANVAS_WIDTH/2, CANVAS_HEIGHT - 50);

    requestAnimationFrame(gameLoop);
}

// ------------------ Старт игры ------------------
async function startGame(song){
    document.getElementById("menu").style.display="none";
    await initMic();
    audio.src = song.audio;
    await loadMidi(song.midi);
    await loadSRT(song.lyrics);
    audio.play();
    gameLoop();
}

// ------------------ Меню песен ------------------
const songs = [
    { title: "Song 1", audio:"songs/song1.mp3", midi:"songs/song1.mid", lyrics:"songs/song1.srt" }
];

const songButtonsDiv = document.getElementById("songButtons");
songs.forEach(song=>{
    let btn = document.createElement("div");
    btn.className = "song-button";
    btn.textContent = song.title;
    btn.onclick = ()=>startGame(song);
    songButtonsDiv.appendChild(btn);
});
</script>

</body>
</html>
